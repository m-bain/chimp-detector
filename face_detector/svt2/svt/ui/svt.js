/*
  Javascript codebase to manage html based user interface
  of Seebibyte Visual Tracker (SVT)

  Author: Abhishek Dutta <adutta@robots.ox.ac.uk>
  Date: 7 Nov. 2018
*/

// core data structures
var via_ng = new _via();                // handles manual annotation of a video
var svt_project = new _svt_project();   // maintains manual and automatic track of objects in a video

// user interface elements used by SVT
var object_panel = document.getElementById('object_panel');
var object_list  = document.getElementById('object_list');
var _svt_object_is_selected = false;
var _svt_trk_is_selected    = false;
var _svt_object_sel_id      = -1;
var _svt_trk_sel_id         = -1;

var rcanvas, rctx; // initialized by _svt_init() to via_ng canvas
var rctx_char_width, rctx_char_height;

// constants
var SVT_PAGE_LIST = {UPLOAD_PAGE:'upload_page',
                     ANNOTATION_VIEWER:'annotation_viewer',
                     ABOUT_PAGE:'about_page'
                    };
var SVT_TRACK_TYPE = { MANUAL:'MANUAL', AUTOMATIC:'AUTOMATIC' };
var SVT_OBJECT_COLOR_LIST = ['yellow', 'red', 'blue', 'green', 'orange', 'black'];

// state variables
var _svt_project_load_ongoing = false;
var _svt_last_page_id = '';

// svt regions correspond to regions of the video
// via regions correspond to the regions current visible and editable regions on a frame
// such that _svt_via_rid_map[ svt_region_hash ] = via_ng_rid
// where, svt_region_hash = { _svt_hash_manual_region(), _svt_hash_segment_region() }
var _svt_via_rid_map = {};
var _via_svt_rid_map = {};

// annotation visualizer
var _svt_show_tracks = false;
var TRACK_DRAW_INTERVAL = 25; // in ms
var _svt_server_address = 'http://localhost:10001';
var FETCH_STATUS_DELAY = 500; // ms
var FETCH_TRACK_DELAY = 100; // ms
var _svt_last_drawn_frame_index = -1; // to avoid redrawing same regions

var now = {'task_id':''};
var _svt_is_tracking_ongoing = false;

// the <div> where you want to show the image being annotated
var _via_view_panel    = document.getElementById('_via_view_panel');
// the <div> where you want to show error/info. messages generated by VIA application
var _via_message_panel = document.getElementById('message_panel');

function _svt_init() {
  // to handle keyboard and mouse events
  _via_view_panel.addEventListener('wheel', _svt_video_on_mouse_wheel, false);

  _svt_show_page(SVT_PAGE_LIST.UPLOAD_PAGE);
  //_svt_show_page(SVT_PAGE_LIST.ANNOTATION_VIEWER);

  //_svt_debug();
}


function _svt_debug() {
  console.log('DEBUG MODE');
  var project_data_str = '{"files":["/data/svt/videos/Moon_transit_of_sun_large.mp4"],"obj":{"0":{"trk":{"0":{"track_id":0,"manual_regions":{"2.177479":[2.177479,1,203,471,123,116]},"seg":{"2.177479":{"start_region":[2.177479,1,203,471,123,116],"end_region":[-1,0,0,0,0,0],"regions":[[2.177479,1,203,471,123,116],[2.244146,0,213,465,121,116],[2.310812,0,221,463,119,116],[2.377479,0,228,460,118,116],[2.444146,0,235,457,116,115],[2.510812,0,244,455,115,115],[2.577479,0,251,452,115,115],[2.644146,0,258,449,114,114],[2.710812,0,267,446,114,114],[2.777479,0,274,444,114,114],[2.844146,0,281,439,114,115],[2.910812,0,287,437,114,115],[2.977479,0,294,433,115,116],[3.044146,0,301,431,115,117],[3.110812,0,309,426,116,117],[3.177479,0,316,423,116,118],[3.244146,0,325,420,117,118],[3.310812,0,332,417,117,118],[3.377479,0,341,412,116,118],[3.444146,0,348,409,116,119],[3.510812,0,356,405,116,119],[3.577479,0,364,402,116,119],[3.644146,0,370,398,116,119],[3.710812,0,378,395,116,119],[3.777479,0,386,391,116,120],[3.844146,0,394,388,116,120],[3.910812,0,400,385,116,120],[3.977479,0,409,382,116,120],[4.044146,0,417,379,116,120],[4.110812,0,425,376,116,120],[4.177479,0,433,373,116,120],[4.244146,0,441,370,116,121]]}}}}}}}';
  _svt_project_init( JSON.parse(project_data_str) );
}


function _svt_project_init(project_data) {
  //// sanity check of project_data
  if ( typeof(project_data.files) === 'undefined' ) {
    console.log('_svt_project_init(): malformed project data');
    return;
  } else {
    if ( project_data.files.length !== 1 ) {
      console.log('_svt_project_init(): cannot import project with multiple files @todo');
      return;
    }
  }

  //// initialize the user interface
  // this is needed for _svt_init_via() because it needs a div with preset size
  _svt_project_load_ongoing = true;
  _svt_show_page(SVT_PAGE_LIST.ANNOTATION_VIEWER);
  _svt_object_panel_clear_objects();

  //// create a new instance of svt_project()
  svt_project = new _svt_project();
  svt_project.import_project(project_data);

  //// initialize VIA (which handles video load, frame annotation, etc)
  // 1. load video file
  // 2. update draw buffer to contain existing regions in svt_project
  // 3. load thumbnail image corresponding to each object
  _svt_init_via(_via_view_panel, _via_message_panel);
  via_ng.c.show_message('Loading file: ' + svt_project.files[0]);
  via_ng.c.add_hook( via_ng.c.hook.id.FILE_LOAD_FINISH, _svt_project_on_video_load_done );
  via_ng.m.add_file_from_url(svt_project.files[0], 'video').then( function(ok) {
    via_ng.c.load_file_from_index(0);
  }, function(err) {
    _svt_project_load_ongoing = false;
    via_ng.c.del_hook( via_ng.c.hook.id.FILE_LOAD_FINISH, _svt_project_on_video_load_done );
    console.log(err);
  });
}

function _svt_project_on_video_load_done() {
  if ( _svt_project_load_ongoing ) {
    console.log('_svt_on_new_project_init_done')

    //// remove hook
    via_ng.c.del_hook( via_ng.c.hook.id.FILE_LOAD_FINISH, _svt_project_on_video_load_done );

    //// update draw buffer with existing regions in svt_project
    svt_project.update_all_buf(via_ng.v.now.tform.scale); // initialize buf with the manual regions

    //// extract thumnail image (shown in object panel) corresponding to each object
    // this is a two step process (applied to all objects in the current project)
    // 1. seek to a time in video where the first object region has been defined
    // 2. extract object region from video frame
    // 3. repeat this process for each object
    via_ng.v.now.content.pause();
    via_ng.v.now.content.addEventListener('seeked', _svt_project_extract_object_thumbnail);
    _svt_project_load_object_thumbnails();
  }
}

function _svt_project_load_object_thumbnails() {
  var oid;
  for ( oid in svt_project.obj ) {
    if ( svt_project.obj.hasOwnProperty(oid) ) {
      if ( ! (svt_project.obj[oid].img instanceof HTMLCanvasElement) ) {
        // trigger load of this image
        var r = svt_project.obj[oid].get_representative_img_region();
        if ( r.length ) {
          via_ng.v.now.content.currentTime = r[0]; // seek to video to extract thumbnail
          return; // continue loading thumnail using _svt_project_extract_object_thumbnail()
        }
      }
    }
  }
  // all the thumnails are now loaded
  via_ng.v.now.content.removeEventListener('seeked', _svt_project_extract_object_thumbnail);
  _svt_object_panel_update();
  _svt_project_on_object_thumbnails_load_done();
}

function _svt_project_extract_object_thumbnail(e) {
  var time = via_ng.v.now.content.currentTime;

  // find the region which is present in this frame
  var oid;
  for ( oid in svt_project.obj ) {
    if ( svt_project.obj.hasOwnProperty(oid) ) {
      var r = svt_project.obj[oid].get_representative_img_region();
      if ( ( Math.abs(r[0] - time) < 1e-6 ) &&
           ! (svt_project.obj[oid].img instanceof HTMLCanvasElement) ) {
        var x = r[2];
        var y = r[3];
        var w = r[4];
        var h = r[5];

        svt_project.obj[oid].img = document.createElement('canvas');
        svt_project.obj[oid].img.width  = w;
        svt_project.obj[oid].img.height = h;
        var ctx = svt_project.obj[oid].img.getContext('2d');
        ctx.drawImage(via_ng.v.now.content, x, y, w, h, 0, 0, w, h);

        // continue the load process
        _svt_project_load_object_thumbnails();
      }
    }
  }
}

function _svt_project_on_object_thumbnails_load_done() {
  _svt_project_load_ongoing = false;
  _svt_av_show_tracks();
  if ( via_ng.v.now.content.paused ) {
    //via_ng.v.now.content.play(); # Google Chrome blocks automatic video play
  }
  console.log('Finished loading project');
}

function _svt_init_via(view_panel, message_panel) {
  via_ng = new _via();
  via_ng.init(view_panel, message_panel);
  message_panel.classList.remove('hide');
  rcanvas = via_ng.v.layers['rshape_canvas'];
  rctx    = rcanvas.getContext('2d');
  rctx.shadowColor = 'transparent';
  rctx.font = '10px Sans';

  rctx_char_width  = rctx.measureText('M').width;
  rctx_char_height = 1.8 * rctx_char_width;

  // capture via hooks
  via_ng.c.add_hook( via_ng.c.hook.id.REGION_DRAWN, _svt_on_region_draw );
  via_ng.c.add_hook( via_ng.c.hook.id.REGION_ADDED, _svt_on_region_add );
  via_ng.c.add_hook( via_ng.c.hook.id.REGION_MOVED, _svt_on_region_move );
  //via_ng.c.add_hook( via_ng.c.hook.id.FILE_LOAD_FINISH, _svt_on_file_load );
  via_ng.c.add_hook( via_ng.c.hook.id.CLICKED_AT, _svt_on_via_click );
  via_ng.c.add_hook( via_ng.c.hook.id.VIDEO_ON_PLAY, _svt_on_video_play );
  via_ng.c.add_hook( via_ng.c.hook.id.VIDEO_ON_PAUSE, _svt_on_video_pause );
  //via_ng.c.add_hook( via_ng.c.hook.id.VIDEO_ON_SEEK, _svt_on_video_seek );
}

// seek to a video and execute a method
// video seeking is async operation and hence this is needed
function _svt_video_seek_and_execute(video, time, handler, param) {
  this.video = video;
  this.handler = handler;

  this.seeked_event_listener = function() {
    this.handler.call(null, param);
    this.video.removeEventListener('seeked', this.seeked_event_listener);
  }.bind(this);

  this.video.addEventListener('seeked', this.seeked_event_listener);
  this.video.pause;
  this.video.currentTime = time;
}

function _svt_project() {
  this.next_object_id = 0;

  // files.length = 1 : for a video file
  // files.length > 1 : for multiple frames from a video
  this.files = [];

  // stores each object
  this.obj = [];

  // draw buffer used to store frame regions
  // in a fast accessible data strucutre
  this.buf = new _svt_draw_buf();
}

_svt_project.prototype.update_buf_from_fetch = function(d, scale) {
  var scale_inv = 1.0 / scale;
  var fetch_list_size = d.fetch_list.length
  var i, j, oid, tid, sid, r, tj;
  for ( i = 0; i < fetch_list_size; ++i ) {
    oid = d.fetch_list[i][0];
    tid = d.fetch_list[i][1];
    sid = d.fetch_list[i][2];

    var fetch_i_size = d.fetch_result[i].length;
    for ( j = 0; j < fetch_i_size; ++j ) {
      tj = d.fetch_result[i][j][0];
      r = [];
      r[0] = oid;
      r[1] = d.fetch_result[i][j][1];
      r[2] = Math.round( d.fetch_result[i][j][2] * scale_inv );
      r[3] = Math.round( d.fetch_result[i][j][3] * scale_inv );
      r[4] = Math.round( d.fetch_result[i][j][4] * scale_inv );
      r[5] = Math.round( d.fetch_result[i][j][5] * scale_inv );
      this.buf.add_region(tj, r);
    }
  }
}

_svt_project.prototype.update_all_buf = function(scale) {
  this.buf = new _svt_draw_buf();
  var oid, tid, sid;
  var scale_inv = 1.0 / scale;
  var r, i, ti;
  for ( oid in svt_project.obj ) {
    for ( tid in svt_project.obj[oid].trk ) {
      for ( sid in svt_project.obj[oid].trk[tid].seg ) {
        var region_count = svt_project.obj[oid].trk[tid].seg[sid].regions.length;
        for ( i = 0; i < region_count; ++i ) {
          ti = svt_project.obj[oid].trk[tid].seg[sid].regions[i][0];
          r = [];
          r[0] = oid;
          r[1] = svt_project.obj[oid].trk[tid].seg[sid].regions[i][1];
          r[2] = Math.round( svt_project.obj[oid].trk[tid].seg[sid].regions[i][2] * scale_inv );
          r[3] = Math.round( svt_project.obj[oid].trk[tid].seg[sid].regions[i][3] * scale_inv );
          r[4] = Math.round( svt_project.obj[oid].trk[tid].seg[sid].regions[i][4] * scale_inv );
          r[5] = Math.round( svt_project.obj[oid].trk[tid].seg[sid].regions[i][5] * scale_inv );
          this.buf.add_region(ti, r);
        }
      }
    }
  }
  console.log('_svt_project.prototype.update_all_buf()')
  console.log(this.buf.keyframe)
  console.log(this.buf.video_frames);
}

_svt_project.prototype.export_manual_regions = function() {
  return new Promise( function(ok_callback, err_callback) {
    var d = {};
    d.files = this.files.slice(0);
    d.obj = {};
    var oid, tid;
    try {
      for ( oid in this.obj ) {
        if ( this.obj.hasOwnProperty(oid) ) {
          d.obj[oid] = { 'trk':{} };
          for ( tid in this.obj[oid].trk ) {
            if ( this.obj[oid].trk.hasOwnProperty(tid) ) {
              d.obj[oid].trk[tid] = { 'track_id':tid, 'seg':{} };
              d.obj[oid].trk[tid].manual_regions = JSON.parse(JSON.stringify(this.obj[oid].trk[tid].manual_regions));
            }
          }
        }
      }
      ok_callback(d);
    }
    catch(err) {
      console.log(err)
      err_callback(err);
    }
  }.bind(this));
}


_svt_project.prototype.export_project = function() {
  return new Promise( function(ok_callback, err_callback) {
    var d = {};
    d.files = this.files.slice(0);
    d.obj = {};
    var oid, tid;
    try {
      for ( oid in this.obj ) {
        if ( this.obj.hasOwnProperty(oid) ) {
          d.obj[oid] = { 'trk':{} };
          for ( tid in this.obj[oid].trk ) {
            if ( this.obj[oid].trk.hasOwnProperty(tid) ) {
              d.obj[oid].trk[tid] = JSON.parse( JSON.stringify(this.obj[oid].trk[tid]) );
            }
          }
        }
      }
      ok_callback(d);
    }
    catch(err) {
      console.log(err)
      err_callback(err);
    }
  }.bind(this));
}

_svt_project.prototype.import_project = function(d) {
  this.files = d.files.slice(0);
  this.buf = new _svt_draw_buf();

  this.obj = {};
  var oid, tid, rid;
  for ( oid in d.obj ) {
    if ( d.obj.hasOwnProperty(oid) ) {
      this.obj[oid] = new _svt_object(oid, {}); // object image is initialized separately
      if ( typeof(d.obj[oid].trk) !== 'undefined' ) {
        for ( tid in d.obj[oid].trk ) {
          this.obj[oid].trk[tid] = new _svt_track(tid);
          this.obj[oid].trk[tid].import_data( d.obj[oid].trk[tid] );
          if ( Object.keys(d.obj[oid].trk[tid].seg).length === 0 ) {
            // looks like manual annotations, import
            // segments are empty, initialize them
            this.obj[oid].trk[tid].init_segments();
          }
        }
      }
    }
  }

  if ( typeof(oid) === 'undefined' ) {
    this.next_object_id = 0;
  } else {
    this.next_object_id = parseInt(oid) + 1;
  }
}

_svt_project.prototype.import_manual_annotations = function(d) {
  this.files = d.files.slice(0);
  this.buf = new _svt_draw_buf();

  this.obj = {};
  var oid, tid, rid;
  for ( oid in d.obj ) {
    if ( d.obj.hasOwnProperty(oid) ) {
      this.obj[oid] = new _svt_object(oid, {}); // object image is initialized separately

      if ( typeof(d.obj[oid].trk) !== 'undefined' ) {
        for ( tid in d.obj[oid].trk ) {
          this.obj[oid].trk[tid] = new _svt_track(tid);
          this.obj[oid].trk[tid].manual_regions = JSON.parse( JSON.stringify(d.obj[oid].trk[tid].manual_regions) );
          this.obj[oid].trk[tid].init_segments();
        }
      }
    }
  }
  this.next_object_id = parseInt(oid) + 1;
}

// copy start regions from manual track annotations
_svt_project.prototype.init_track_segments = function() {
  var oid, tid;
  for ( oid in this.obj ) {
    for ( tid in this.obj[oid].trk ) {
      this.obj[oid].trk[tid].init_segments();
    }
  }
}

// d.fetch_list = [ [oid,tid,rid,t0,t1], ...]
// d.fetch_result[k] = [ [time, x, y, width, height], ... ]
_svt_project.prototype.update_from_fetch = function(d) {
  if ( typeof(d.fetch_list) === 'undefined' ||
       typeof(d.fetch_result) === 'undefined' ) {
    console.log('_svt_project.prototype.update() failed due to malformed input!');
    console.log(d)
    return;
  }
  if ( d.fetch_list.length !== d.fetch_result.length ) {
    console.log('_svt_project.prototype.update() failed due mismatched data!');
    console.log(d)
    return;
  }

  var fetch_list_size = d.fetch_list.length
  var i, j, oid, tid, sid;
  for ( i = 0; i < fetch_list_size; ++i ) {
    oid = d.fetch_list[i][0];
    tid = d.fetch_list[i][1];
    sid = d.fetch_list[i][2];

    var fetch_i_size = d.fetch_result[i].length;
    for ( j = 0; j < fetch_i_size; ++j ) {
      this.obj[oid].trk[tid].seg[sid].regions.push( d.fetch_result[i][j] );
    }
  }
}

_svt_project.prototype.create_new_object = function(object_img) {
  var oid = this.next_object_id;
  this.next_object_id = this.next_object_id + 1;
  this.obj[oid] = new _svt_object(oid, object_img);
  return oid;
}
_svt_project.prototype.del_object = function(oid) {
  delete this.obj[oid];
}

//
// Maintains a data structure to store all manually and
// automatically annotatated region
//
function _svt_object(object_id, object_img) {
  this.oid = object_id;
  this.img = object_img;
  this.next_trk_id = 0;
  this.trk = {}; // track annotations
}
_svt_object.prototype.clone = function(svt_object) {
  for ( var key in svt_object ) {
    if ( svt_object.hasOwnProperty(key) ) {
      this[key] = svt_object[key];
    }
  }
}

_svt_object.prototype.create_new_track = function() {
  var tid = this.next_trk_id;
  this.next_trk_id = this.next_trk_id + 1;
  this.trk[tid] = new _svt_track(tid);
  return tid;
}

_svt_object.prototype.del_track = function(tid) {
  delete this.trk[tid];
}

_svt_object.prototype.get_representative_img_region = function() {
  var tid, rid;
  for ( tid in this.trk ) {
    if ( this.trk.hasOwnProperty(tid) ) {
      for ( rid in this.trk[tid].manual_regions ) {
        if ( this.trk[tid].manual_regions.hasOwnProperty(rid) ) {
          return this.trk[tid].manual_regions[rid];
        }
      }
    }
  }
  return [];
}

// a track is defined using a collection of manually drawn regions in multiple video frames
// manual_regions[rid] = [time, is_manual, x, y, width, height]
// where,
//   rid = get_rid(time)
//
// seg[sid] = {'start_region':..., 'end_region':..., 'regions':[...]}
// where,
//   sid = get_rid( seg[sid].start_region[0] )

function _svt_track(track_id) {
  this.track_id = track_id;
  this.manual_regions = {}; // an array of [time, is_manual, x, y, width, height]
  this.seg = {};            // an array of _svt_segment()
}

_svt_track.prototype.import_data = function(d) {
  this.manual_regions = {};
  var rid;
  for ( rid in d.manual_regions ) {
    this.add_manual_region( d.manual_regions[rid], rid );
  }

  var sid;
  for ( sid in d.seg ) {
    this.seg[sid] = new _svt_trk_segment(d.seg[sid].start_region, d.seg[sid].end_region);
    this.seg[sid].regions = d.seg[sid].regions.slice(0);
  }
}

_svt_track.prototype.get_rid = function(d) {
  var time;
  if (d instanceof Array ) {
    time = d[0];
  } else {
    time = d;
  }
  var tt = Number( (time).toFixed(6) );
  return tt.toString();
}

_svt_track.prototype.get_manual_rid_list = function() {
  return Object.keys(this.manual_regions).sort();
}

// r = [time, is_manual, x, y, width, height]
_svt_track.prototype.add_manual_region = function(r, rid) {
  if ( typeof(rid) === 'undefined' ) {
    rid = this.get_rid( r[0] );
  }
  this.manual_regions[ rid ] = r;
  this.init_segments();
  return rid;
}

_svt_track.prototype.del_manual_region = function(rid) {
  if ( this.manual_regions.hasOwnProperty(rid) ) {
    delete this.manual_regions[rid];
  }
}

// initialize track segments from manual regions
_svt_track.prototype.init_segments = function() {
  this.seg = {};
  var region_time_list = Object.keys(this.manual_regions);
  region_time_list.sort();
  var nr = region_time_list.length;
  var region, i, sid, start_region, end_region;
  if ( nr === 1 ) {
    start_region = this.manual_regions[ region_time_list[0] ];
    end_region   = [-1,0,0,0,0,0]; // track until end
    sid = region_time_list[0];
    this.seg[sid] = new _svt_trk_segment(start_region, end_region);
    this.seg[sid].add_region(start_region);
  } else {
    for ( i = 0; i < nr - 1; ++i ) {
      start_region = this.manual_regions[ region_time_list[i] ];
      end_region   = this.manual_regions[ region_time_list[i+1] ];
      sid = region_time_list[i];
      this.seg[sid] = new _svt_trk_segment(start_region, end_region);
      this.seg[sid].add_region(start_region);
    }
  }
}

// r = [time, is_manual, x, y, width, height]
_svt_track.prototype.add_region = function(sid, r) {
  this.seg[sid].add_region(r);
}

function _svt_trk_segment(start_region, end_region) {
  this.start_region = start_region;
  this.end_region   = end_region;
  this.regions = [];
}

_svt_trk_segment.prototype.add_region = function(r) {
  this.regions.push( r );
}
_svt_trk_segment.prototype.first_region = function() {
  return this.regions[0];
}
_svt_trk_segment.prototype.last_region = function() {
  return this.regions[ this.regions.length - 1 ];
}
_svt_trk_segment.prototype.region_count = function() {
  return this.regions.length;
}

//
// Maintains regions for each frame that is required
// to overlay regions on frames when video is playing
//
// Stores regions for each frame in a compact way
// such that they can be retrived efficiently using
// either frame_offset or time value
//
// time (t) is quantized such that
//   t = t0 + t1*0.1 + t2*0.01
// and stored regions corresponding to each quantized
// time is stored in an array at index value given by:
//   index = t2 + t1*10 + t2*100;
// such that the k regions for frame quantized at index is
//   this.buf[index] = [id0,x0,y0,width0,height0, ..., idk,xk,yk,widthk,heightk]
//
// for a given video time "t",
// time_index = this.time2index(time)
// keyframe_index = this.frame_data[ time_index ]
// time_regions = this.keyframe[ keyframe_index ]
function _svt_draw_buf() {
  this.keyframe = [];   // video frames for which regions are defined
  this.video_frames = []; // keyframe list of all video frames
}

// each 1 second is quantized into 25 bins (because commonly videos are 25fps)
// therefore,
// index 0  to 24 used for 0.0 to 0.99 sec.
// index 25 to 49 used for 1.0 to 1.99 sec.
// ...
_svt_draw_buf.prototype.time2index = function(time) {
  var q0 = Math.floor(time);
  var q1 = Math.floor( (time - q0 + 0.000001) * 25 )
  return q0 * 25 + q1;
}

// time is monotonically increasing for every invocation of this method
_svt_draw_buf.prototype.add_region = function(time, region) {
  var frame1_index = this.time2index(time);
  console.log('time=' + time + ':' + frame1_index);
  // add this region as a keyframe
  var keyframe1_index = this.keyframe.push(region) - 1;
  this.video_frames[frame1_index] = keyframe1_index;

  // find the video_frame index of the previous keyframe (i.e. non-empty video_frame)
  var frame0_index = frame1_index;
  var keyframe0_index = keyframe1_index;
  var i;
  for ( i = frame1_index - 1; i >= 0; --i ) {
    if ( typeof(this.video_frames[i]) !== 'undefined' ) {
      frame0_index = i;
      keyframe0_index = this.video_frames[frame0_index]
      break;
    }
  }

  // interpolate between frame0_index and frame1_index such that
  // this.keyframe[frame0_index] = keyframe0_index
  // this.keyframe[frame1_index] = keyframe1_index
  var dist = frame1_index - frame0_index;
  if ( dist > 1 ) {
    var keyframe_index = keyframe0_index;
    var mid_point = Math.floor( (frame0_index + frame1_index) / 2 );
    for ( i = frame0_index + 1; i < frame1_index; ++i ) {
      this.video_frames[i] = keyframe_index;
      if ( i === mid_point ) {
        keyframe_index = keyframe1_index;
      }
    }
  }
}

//
// SVT helper functions
//
function _svt_show_video_page() {
  if ( svt_project.files.length ) {
    _svt_show_page(SVT_PAGE_LIST.ANNOTATION_VIEWER);
  } else {
    _svt_show_page(SVT_PAGE_LIST.UPLOAD_PAGE);
  }
}

function _svt_toggle_page(page_id) {
  var p = document.getElementById(page_id);
  if ( p.classList.contains('show') ) {
    _svt_show_page(_svt_last_page_id);
  } else {
    _svt_show_page(page_id);
  }
}

function _svt_show_page(page_id) {
  _svt_hide_all_pages();
  var p = document.getElementById(page_id);
  if ( p ) {
    p.classList.add('show');
  }
}

function _svt_hide_all_pages() {
  var pages = document.getElementsByClassName('page');
  for ( var i = 0; i < pages.length; ++i ) {
    if ( pages[i].classList.contains('show') ) {
      pages[i].classList.remove('show');
      _svt_last_page_id = pages[i].id;
    }
  }
}

function _svt_select_new_video_file() {
  var p = document.getElementById('input_video_path');
  if ( p ) {
    var project_data = {'files':[ p.value ]};
    _svt_project_init(project_data);
  }
}

//
// object panel contains all the objects currently
// annotated and selected by the user
//
function _svt_object_panel_update(oid, tid) {
  if ( typeof(oid) === 'undefined' ) {
    // update the full object panel
    _svt_object_panel_clear('start_info object_list');
    var object_id;
    for ( object_id in svt_project.obj ) {
      _svt_object_panel_add(object_id);
    }
  } else {
    if ( typeof(tid) === 'undefined' ) {
      // update all tracks of an object
      var c_old = document.getElementById( _svt_object_panel_htmlid(oid) );
      var c_new = _svt_object_panel_create_obj_html(oid);
      if ( c_old ) {
        c_new.classList = c_old.classList;
        object_list.replaceChild(c_new, c_old);
      } else {
        object_list.appendChild(c_new);
      }
    } else {
      // update a single track of an object
      var trk_old = document.getElementById( _svt_trk_htmlid(oid,tid) );
      var trk_new = _svt_object_panel_obj_trk_timestamp_html(oid, tid);
      if ( trk_old ) {
        trk_new.classList = trk_old.classList;
        trk_old.parentNode.replaceChild(trk_new, trk_old);
      }}
  }
}

function _svt_object_panel_add(oid) {
  var c = _svt_object_panel_create_obj_html(oid);
  object_list.appendChild(c);
}

function _svt_object_panel_create_obj_html(oid) {
  if ( ! object_list ) {
    return false;
  }

  var c = document.createElement('div');
  c.classList.add('object')
  c.setAttribute('id', _svt_object_panel_htmlid(oid));

  var info = document.createElement('div');
  info.classList.add('info');
  var s1 = document.createElement('span');
  s1.innerHTML = 'Object ' + oid;
  var s2 = document.createElement('span');
  s2.classList.add('otool');
  s2.innerHTML = '<span class="text_button" title="Delete this object" ' +
    'onclick="_svt_object_del(' + oid + ')">&times;</span>';
  info.appendChild(s1);
  info.appendChild(s2);
  c.appendChild(info);

  // HTML canvas containing the image of object
  var img = document.createElement('div');
  img.setAttribute('onclick', '_svt_object_toggle_select(' + oid + ')');
  img.appendChild( svt_project.obj[oid].img );
  c.appendChild(img);

  var t = document.createElement('table');
  var thead = document.createElement('thead');
  thead.innerHTML = '<tr><th colspan="2">trk-id</th><th colspan="2">manual regions</th></tr>';
  t.appendChild(thead);
  var tbody = document.createElement('tbody');
  var tid, rid, region_count;
  for ( tid in svt_project.obj[oid].trk ) {
    if ( svt_project.obj[oid].trk.hasOwnProperty(tid) ) {
      var tr = document.createElement('tr');

      // track selector
      var td0 = document.createElement('td');
      var c0 = document.createElement('input');
      c0.setAttribute('type', 'checkbox');
      c0.setAttribute('title', 'Select this track');
      c0.setAttribute('onchange', '_svt_trk_toggle_select(this, ' + oid + ',' + tid + ')');
      td0.appendChild(c0);
      tr.appendChild(td0);

      // track id
      var td1 = document.createElement('td');
      td1.innerHTML = tid;
      tr.appendChild(td1);

      // track timestamps
      tr.appendChild( _svt_object_panel_obj_trk_timestamp_html(oid, tid));

      // track controls
      var td3 = document.createElement('td');
      var c1 = document.createElement('span');
      c1.setAttribute('class', 'text_button');
      c1.setAttribute('title', 'Delete this track');
      c1.setAttribute('onclick', '_svt_trk_delete(' + oid + ',' + tid + ')');
      c1.innerHTML = '&times;'
      td3.appendChild(c1);

      tr.appendChild(td3);
      tbody.appendChild(tr)
    }
  }
  t.appendChild(tbody);

  c.appendChild(t);
  return c;
}

function _svt_object_panel_obj_trk_timestamp_html(oid, tid) {
  var td = document.createElement('td');
  td.setAttribute('id', _svt_trk_htmlid(oid, tid));

  var rid_list = svt_project.obj[oid].trk[tid].get_manual_rid_list();
  var nrid = rid_list.length;
  var tstr, i, rid;
  for ( i = 0; i < nrid; ++i ) {
    rid = rid_list[i];
    tstr = _svt_time2str( svt_project.obj[oid].trk[tid].manual_regions[rid][0] )
    var thtml = document.createElement('span');
    thtml.setAttribute('class', 'text_button');
    thtml.setAttribute('title', 'Jump to this track region in video');
    thtml.setAttribute('onclick', '_svt_trk_jump_to_region(' + oid + ',' + tid + ',' + rid + ')');
    thtml.innerHTML = tstr;
    td.appendChild(thtml);

    if ( i !== (nrid - 1) ) {
      var space = document.createElement('span');
      space.innerHTML = ', ';
      td.appendChild(space);
    }
  }
  return td;
}

function _svt_object_panel_clear(class_list) {
  var p = object_panel.getElementsByClassName(class_list);
  if ( p.length != 0 ) {
    for ( var i = 0; i < p.length; ++i ) {
      object_panel.removeChild( p[i] );
    }
  }
}

function _svt_object_panel_clear_objects() {
  var p = document.getElementById('object_list');
  p.innerHTML = '';
}

function _svt_object_panel_htmlid(oid) {
  return '_svt_oid_' + oid;
}

function _svt_object_panel_parse_htmlid(html_oid) {
  return parseInt( html_oid.substr( '_svt_oid_'.length ) );
}

function _svt_trk_htmlid(oid,tid) {
  return '_svt_oid_' + oid + '_tid_' + tid;
}

function _svt_trk_parse_htmlid(htmlid) {
  // _svt_oid_?_tid_?
  var p0 = htmlid.indexOf('_tid_');
  var tid = parseInt( htmlid.substr(p0 + 5) );

  var p1 = htmlid.indexOf('_oid_') + 5;
  var oid = parseInt( htmlid.substr(p1, p0 - p1) );
  return {'oid':oid, 'tid':tid};
}

function _svt_trk_jump_to_region(oid, tid, rid) {
  var r = svt_project.obj[oid].trk[tid].manual_regions[rid];
  var t = r[0];
  var scale = via_ng.v.now.tform.scale;
  var xs = Math.round( r[1] / scale );
  var ys = Math.round( r[2] / scale );
  var ws = Math.round( r[3] / scale );
  var hs = Math.round( r[4] / scale );

  _svt_via_clear_regions();
  var param = {'oid':oid, 'tid':tid, 'rid':rid};
  var jne = new _svt_video_seek_and_execute(via_ng.v.now.content, t, _svt_via_draw_manual_region, param);
}

function _svt_object_del(oid) {
  svt_project.del_object(oid);
  var p = document.getElementById( _svt_object_panel_htmlid(oid) );
  object_list.removeChild(p);
}

function _svt_object_toggle_select(oid) {
  if ( _svt_object_is_selected ) {
    if ( _svt_object_sel_id === oid ) {
      _svt_object_remove_select(oid);
    } else {
      _svt_object_select(oid);
    }
  } else {
    _svt_object_select(oid);
  }
}

function _svt_object_select(oid) {
  _svt_object_clear_all_selection();
  _svt_object_sel_id = oid;
  _svt_object_is_selected = true;
  _svt_object_set_select_state(oid, true);
  _svt_object_scroll_to(oid);
}

function _svt_object_scroll_to(oid) {
  var p = document.getElementById( _svt_object_panel_htmlid(oid) );
  p.scrollIntoView();
}

function _svt_object_remove_select(oid) {
  _svt_object_is_selected = false;
  _svt_object_sel_id = -1;
  _svt_object_set_select_state(oid, false);
  console.log('removed object selection='+oid);
}

function _svt_object_is_selected(oid) {
  var html_id = _svt_object_panel_htmlid(oid);
  var p = document.getElementById(html_id);
  if ( p.classList.contains('selected') ) {
    return true;
  } else {
    return false;
  }
}

function _svt_object_set_select_state(oid, is_selected) {
  var html_id = _svt_object_panel_htmlid(oid);
  var p = document.getElementById(html_id);
  if ( p ) {
    if ( is_selected ) {
      if ( ! p.classList.contains('selected') ) {
        p.classList.add('selected');
      }
    } else {
      if ( p.classList.contains('selected') ) {
        p.classList.remove('selected');
      }
    }
  }
}

function _svt_object_clear_all_selection() {
  _svt_object_is_selected = false;
  _svt_object_sel_id = -1;

  var ol = object_panel.getElementsByClassName('object');
  var n = ol.length;
  for ( var i = 0; i < n; ++i ) {
    if ( ol[i].classList.contains('selected') ) {
      ol[i].classList.remove('selected');
    }
  }
}

function _svt_trk_toggle_select(p, oid, tid) {
  if ( _svt_object_sel_id === oid ) {
    if ( _svt_trk_sel_id === tid ) {
      if ( p.checked === false ) {
        // remove track selection, retain object selection
        _svt_trk_unselect(tid);
      }
    } else {
      // select another track of the same object
      if ( p.checked === true ) {
        _svt_trk_select(tid);
      }
    }
  } else {
    if ( p.checked === true ) {
      // select another object and its track
      _svt_object_select(oid);
      _svt_trk_select(tid);
    }
  }
}

function _svt_trk_select(tid) {
  console.log('track selected=' + tid);
  _svt_trk_is_selected = true;
  _svt_trk_sel_id = tid;
}

function _svt_trk_unselect(tid) {
  console.log('removed track selection=' + tid);
  _svt_trk_is_selected = false;
  _svt_trk_sel_id = -1;
}

function _svt_trk_delete(oid, tid) {
  console.log(svt_project.obj[oid])
  console.log(tid)
  svt_project.obj[oid].del_track(tid);
  _svt_object_panel_update(oid);
}

function _svt_object_panel_on_click_outside(event) {
  if ( event.target.id === 'object_panel' ) {
    _svt_object_clear_all_selection();
  }
}

//
// annotation import and export
function _svt_import_sel_local_file() {
  var invisible_file_input = document.getElementById('invisible_file_input');
  if (invisible_file_input) {
    invisible_file_input.accept='.json';
    invisible_file_input.onchange = _svt_import_sel_local_file_done;
    invisible_file_input.removeAttribute('multiple');
    invisible_file_input.click();
  }
}

function _svt_import_sel_local_file_done(event) {
  _svt_load_text_file(event.target.files[0], _svt_import_local_file_load_done);
}

function _svt_import_local_file_load_done(project_data_str) {
  _svt_project_init( JSON.parse(project_data_str) );
}

function _svt_export_annotations() {
  if ( svt_project.files.length === 0 ) {
    via_ng.c.show_message('No video file exists to export data');
    return;
  }

  var filename = 'svt_manual_annotations.json';
  if ( svt_project.files.length === 1 ) {
    filename = _svt_extract_filename_from_path(svt_project.files[0]) + '_manual_annotations.json';
  }

  svt_project.export_project().then( function(ok_data) {
    console.log(ok_data)
    var data_blob = new Blob( [ JSON.stringify(ok_data) ],
                              {type:'text/json;charset=utf-8'});
    _svt_save_data_to_local_file(data_blob, filename);
  }, function(err) {
    console.log(err);
    via_ng.c.show_message('Failed to download annotation: ' + err);
  });
}

function _svt_export_manual_annotations() {
  if ( svt_project.files.length === 0 ) {
    via_ng.c.show_message('No video file exists to export data');
    return;
  }

  var filename = 'svt_manual_annotations.json';
  if ( svt_project.files.length === 1 ) {
    filename = _svt_extract_filename_from_path(svt_project.files[0]) + '_manual_annotations.json';
  }

  svt_project.export_manual_regions().then( function(ok_data) {
    console.log(ok_data)
    var data_blob = new Blob( [ JSON.stringify(ok_data) ],
                              {type:'text/json;charset=utf-8'});
    _svt_save_data_to_local_file(data_blob, filename);
  }, function(err) {
    console.log(err);
    via_ng.c.show_message('Failed to download annotation: ' + err);
  });
}

//
// Visualization of frames in video
//

function _svt_annotation_show_frame_regions(select, oid) {
  var rid = parseInt( select.options[select.selectedIndex].value );
  var time = svt_project.obj.trk[oid].regions[rid][0];

  via_ng.v.now.content.pause();
  via_ng.v.now.content.currentTime = time;
  _svt_annotation_draw_frame_manual_regions(oid, rid);
}

function _svt_annotation_draw_frame_manual_regions(oid, rid) {
  _svt_clear_via_regions();
  _svt_frame_clear();
  var n = svt_project.obj.trk[oid].regions.length;
  var r = svt_project.obj.trk[oid].regions[rid];

  var scale = via_ng.v.now.tform.scale;
  var xs = Math.round( r[2] / scale );
  var ys = Math.round( r[3] / scale );
  var ws = Math.round( r[4] / scale );
  var hs = Math.round( r[5] / scale );

  var label = (oid).toString();
  if ( rid === 0 ) {
    label = label + ' : START';
  } else {
    if ( rid === n - 1 ) {
      label = label + ' : END';
    }
  }

  _svt_frame_draw_region(xs, ys, ws, hs);
  _svt_frame_draw_oid(label, xs, ys, ws, hs);
}

function _svt_frame_draw_region(x, y, w, h) {
  rctx.strokeStyle = "yellow";
  rctx.lineWidth = 2;
  rctx.strokeRect(x, y, w, h);
}

function _svt_frame_draw_oid(label, x, y, w, h) {
  var bgnd_rect_width = rctx.measureText(label).width + rctx_char_width;
  rctx.fillStyle = 'black';
  rctx.fillRect(x,
                Math.round(y - 1.1*rctx_char_height),
                Math.round(bgnd_rect_width),
                Math.round(rctx_char_height)
               );
  rctx.fillStyle = 'yellow';
  rctx.fillText(label,
                Math.round(x + 0.4*rctx_char_width),
                Math.round(y - 0.35*rctx_char_height));
}

function _svt_frame_clear() {
  rctx.clearRect(0, 0, rcanvas.width, rcanvas.height);
}

function _svt_via_clear_regions() {
  via_ng.v.layers['rshape'].innerHTML = '';
}

function _svt_clear_all_regions() {
  _svt_via_clear_regions();
  _svt_frame_clear();
}

//
// methods that capture and handle via_ng hooks
//
function _svt_on_region_add(region) {
  console.log('_svt_on_region_add()');
}

function _svt_on_region_draw(region) {
  console.log('_svt_on_region_draw()');

  var via_fileid = region.fileid;
  var via_rid    = region.rid;
  var r = this.via_ng.m.regions[via_fileid][via_rid];
  var x, y, x2, y2;
  // when user draws rectangle starting from bottom right corner
  // we have (x1,y1) > (x2,y2)
  if ( r.dimg[0] < r.dimg[2] ) {
    x = r.dimg[0];
    x2 = r.dimg[2];
  } else {
    x = r.dimg[2];
    x2 = r.dimg[0];
  }
  if ( r.dimg[1] < r.dimg[3] ) {
    y = r.dimg[1];
    y2 = r.dimg[3];
  } else {
    y = r.dimg[3];
    y2 = r.dimg[1];
  }

  var w  = x2 - x;
  var h = y2 - y;
  var time = this.via_ng.v.now.content.currentTime;

  var object_img = document.createElement('canvas');
  object_img.width = w;
  object_img.height = h;
  var ctx = object_img.getContext('2d');
  ctx.drawImage(via_ng.v.now.content, x, y, w, h, 0, 0, w, h);

  var oid, tid, rid;
  if ( _svt_object_is_selected ) {
    oid = _svt_object_sel_id;
    if ( _svt_trk_is_selected ) {
      tid = _svt_trk_sel_id;
      // add the new region to selected track
      rid = svt_project.obj[oid].trk[tid].add_manual_region( [time, 1, x, y, w, h] );
      _svt_object_panel_update(oid, tid);
    } else {
      // create a new track and add a region to it
      tid = svt_project.obj[oid].create_new_track();
      rid = svt_project.obj[oid].trk[tid].add_manual_region( [time, 1, x, y, w, h] );
      _svt_object_panel_update(oid);
    }
  } else {
    // create a new object, add a new track and add a region to it
    oid = svt_project.create_new_object(object_img);
    tid = svt_project.obj[oid].create_new_track();
    rid = svt_project.obj[oid].trk[tid].add_manual_region([time, 1, x, y, w, h]);
    _svt_object_panel_add(oid);
  }
  _svt_via_add_rid_map(via_rid, oid, tid, rid);
}

function _svt_on_region_move(region) {
  console.log('_svt_on_region_move()');

  var via_fileid = region.fileid;
  var via_rid    = region.rid;
  var r = this.via_ng.m.regions[via_fileid][via_rid];
  var x = r.dimg[0];
  var y = r.dimg[1];
  var w  = r.dimg[2] - r.dimg[0];
  var h = r.dimg[3] - r.dimg[1];
  var time = this.via_ng.v.now.content.currentTime;

  var svt_hash = _via_svt_rid_map[ via_rid ];
  // @todo: update manual tracks when they are moved
}

function _svt_on_file_load() {
}

function _svt_on_via_click() {
  console.log('_svt_on_via_click()');
  via_ng.v.now.content.play();
}

function _svt_on_video_play() {
  _svt_clear_all_regions(); // deletes all regions (in via and on html)

  document.getElementById('filecontent').classList.remove('video_annotation_mode');
  document.getElementById('filecontent').classList.add('video_play_mode');
  document.getElementById('video_jump_value').value = '';
  via_ng.c.show_message('PLAY MODE: Click anywhere on the video to enter frame annotation mode');
}

function _svt_on_video_pause() {
  document.getElementById('filecontent').classList.add('video_annotation_mode');
  document.getElementById('filecontent').classList.remove('video_play_mode');
  if ( via_ng.v.now.content ) {
    document.getElementById('video_jump_value').value = via_ng.v.now.content.currentTime;
  }

  via_ng.c.show_message('ANNOTATION MODE: Draw regions or [Click] on the frame to play the video');
}

//
// utils
//

function _svt_load_text_file(text_file, callback_function) {
  if (text_file) {
    var text_reader = new FileReader();
    text_reader.addEventListener( 'progress', function(e) {
      console.log('Loading data from file : ' + text_file.name + ' ... ');
    }, false);

    text_reader.addEventListener( 'error', function() {
      console.log('Error loading data text file :  ' + text_file.name + ' !');
      callback_function('');
    }, false);

    text_reader.addEventListener( 'load', function() {
      callback_function(text_reader.result);
    }, false);
    text_reader.readAsText(text_file, 'utf-8');
  }
}


function _svt_save_data_to_local_file(data_blob, filename) {
  var a      = document.createElement('a');
  a.href     = URL.createObjectURL(data_blob);
  a.target   = '_blank';
  a.download = filename;

  // simulate a mouse click event
  var event = new MouseEvent('click', {
    view: window,
    bubbles: true,
    cancelable: true
  });

  a.dispatchEvent(event);
}

function _svt_extract_filename_from_path(path) {
  var last_slash;
  if ( path.includes('\\') ) {
    // windows path
    last_slash = path.lastIndexOf('\\');
  } else {
    if ( path.includes('/') ) {
      // linux path
      last_slash = path.lastIndexOf('/');
    } else {
      return path;
    }

  }
  return path.substring(last_slash + 1);
}

//
// controls for video content
//

function _svt_video_on_mouse_wheel(e) {
  e.preventDefault();
  if (e.deltaY < 0) {
    _svt_video_prev_frame();
  } else {
    _svt_video_next_frame();
  }
}

function _svt_video_play() {
  via_ng.v.now.content.play();
}

function _svt_video_pause() {
  via_ng.v.now.content.pause();
}

function _svt_video_next_frame() {
  // @todo: pool requests if multiple
  // events are triggered, ensure
  if ( ! via_ng.v.now.content.paused ) {
    via_ng.v.now.content.pause();
  }
  _svt_clear_all_regions();
  var current_time = via_ng.v.now.content.currentTime;
  via_ng.v.now.content.currentTime = current_time + 0.04; // assuming video is 25 fps
  document.getElementById('video_jump_value').value = via_ng.v.now.content.currentTime;
}

function _svt_video_prev_frame() {
  if ( ! via_ng.v.now.content.paused ) {
    via_ng.v.now.content.pause();
  }
  _svt_clear_all_regions();
  var current_time = via_ng.v.now.content.currentTime;
  via_ng.v.now.content.currentTime = current_time - 0.04; // assuming video is 25 fps
  document.getElementById('video_jump_value').value = via_ng.v.now.content.currentTime;
}

function _svt_video_update_playback_rate(p) {
  via_ng.v.now.content.playbackRate = parseFloat(p.options[ p.selectedIndex ].value);
  via_ng.c.show_message('Playback rate is now ' + via_ng.v.now.content.playbackRate + 'x');
}

function _svt_video_jump_to(p) {
  if ( ! via_ng.v.now.content.paused ) {
    via_ng.v.now.content.pause();
  }
  via_ng.v.now.content.currentTime = parseFloat( p.value );
}

function _svt_time2str(t) {
  var tt = Number( (t).toFixed(2) );
  return tt.toString()
}

//
// interface between svt and via
//

// add all existing regions in svt to via
function _svt_via_init_with_manual_regions() {
  var oid, tid, rid;
  var nr;
  for ( oid in svt_project.obj ) {
    if ( svt_project.obj.hasOwnProperty(oid) ) {
      for ( tid in svt_project.obj[oid].trk ) {
        if ( svt_project.obj[oid].trk.hasOwnProperty(tid) ) {
          for ( rid in svt_project.obj[oid].trk[tid].manual_regions ) {
            var region = svt_project.obj[oid].trk[tid].manual_regions[rid];
            var svt_region_hash = _svt_hash_manual_region(oid, tid, rid);
            _svt_via_add_region(region, svt_region_hash);
          }
        }
      }
    }
  }
}

function _svt_via_add_region(region, svt_region_hash) {
  var t = region[0];
  var scale = via_ng.v.now.tform.scale;
  var xs = Math.round( region[2] / scale );
  var ys = Math.round( region[3] / scale );
  var ws = Math.round( region[4] / scale );
  var hs = Math.round( region[5] / scale );

  via_ng.v.nvertex = [xs, ys, (xs+ws), (ys+hs)];
  var via_rid = via_ng.c.add_region_from_nvertex();
  via_ng.v.nvertex.splice(0);
  via_ng.v.set_state( via_ng.v.state.IDLE );
  _svt_via_add_rid_map(via_rid, svt_region_hash);
  return via_rid;
}

function _svt_via_draw_manual_region(d) {
  var svt_hash = _svt_hash_manual_region(d);
  var via_rid = _svt_via_rid_map[svt_hash];
  if ( typeof(via_rid) === 'undefined' ) {
    // this region is not yet present in via, so we add it
    var region = svt_project.obj[d.oid].trk[d.tid].manual_regions[d.rid];
    var svt_region_hash = _svt_hash_manual_region(d.oid, d.tid, d.rid);
    via_rid = _svt_via_add_region(region, svt_region_hash);
  } else {
    via_ng.c.add_region_to_view(via_rid);
  }
}

function _svt_via_add_rid_map(via_rid, svt_hash) {
  _svt_via_rid_map[ svt_hash ] = via_rid;
  _via_svt_rid_map[ via_rid  ] = svt_hash;
}

function _svt_hash_manual_region(oid, tid, rid) {
  return JSON.stringify( {'oid':oid,'tid':tid,'rid':rid} );
}

function _svt_manual_region_hash_to_id(manual_region_hash) {
  return JSON.parse(manual_region_hash);
}

function _svt_hash_segment_region(oid, tid, sid, index) {
  return JSON.stringify( {'oid':oid,'tid':tid,'sid':sid,'index':index} );
}

function _svt_segment_region_hash_to_id(segment_region_hash) {
  return JSON.parse(segment_region_hash);
}

//
// Tracking
//
function _svt_start_tracking() {
  svt_project.update_all_buf(via_ng.v.now.tform.scale); // initialize buf with the manual regions
  svt_project.init_track_segments(); // clear all segments and initialize with manual regions
  svt_project.export_project().then( function(ok_data) {
    var xhr = new XMLHttpRequest();
    xhr.addEventListener('load', function() {
      var response = xhr.responseText;
      try {
        var d = JSON.parse(response);
        if ( d.task_id ) {
          _svt_on_start_tracking(d.task_id);
        } else {
          console.log('Failed to submit task');
        }
      }
      catch(err) {
        console.log(err)
      }
    });
    xhr.addEventListener('error', function(e) {
      via_ng.c.show_message('Failed to connect to the SVT server!');
      console.log(e)
    });
    xhr.open('POST', _svt_server_address + '/svt/track');
    xhr.send( JSON.stringify(ok_data) );
  }, function(err_data) {
    console.log(err_data)
  });
}

function _svt_on_start_tracking(task_id) {
  now.task_id = task_id;
  _svt_is_tracking_ongoing = true;
  setTimeout(_svt_check_status, FETCH_STATUS_DELAY);
}

function _svt_check_status() {
  if ( ! _svt_is_tracking_ongoing ) {
    return;
  }
  var xhr = new XMLHttpRequest();
  xhr.addEventListener('load', function() {
    try {
      var _svt_server_status = JSON.parse(xhr.responseText);
      var fetch_next = _svt_what_to_fetch_next(_svt_server_status);
      if ( _svt_server_status.all_done ) {
        // fetch everything from "_svt_server_status.done"
        _svt_fetch_track(fetch_next);
          _svt_is_tracking_ongoing = false;
      } else {
        if ( _svt_server_status.now.length || _svt_server_status.done.length ) {
          if ( fetch_next.length ) {
            _svt_fetch_track(fetch_next, _svt_check_status, FETCH_STATUS_DELAY);
          } else {
            // nothing new has been created, so wait
            setTimeout(_svt_check_status, FETCH_STATUS_DELAY);
          }
        } else {
          // tracking has not started yet
          setTimeout(_svt_check_status, FETCH_STATUS_DELAY);
        }
      }
    }
    catch(err) {
      console.log(err)
    }
  });
  xhr.addEventListener('error', function(e) {
    via_ng.c.show_message('Failed to connect to the SVT server!');
    console.log(e)
  });
  xhr.open('GET', _svt_server_address + '/svt/status?task_id=' + now.task_id);
  xhr.send();
}

function _svt_what_to_fetch_next(status_new) {
  var fetch_next = [];
  // 1. Do we have all track data from status['done']=[[oid,tid,rid,tstart,tend]]
  if ( status_new['done'].length ) {
    var done_length = status_new['done'].length;
    var i, di;
    for ( i = 0; i < done_length; ++i ) {
      di = status_new['done'][i];
      var done_oid = di[0];
      var done_tid = di[1];
      var done_sid = di[2];
      var remote_offset_end = di[3];
      var remote_time_end   = di[4];

      var local_offset_now = svt_project.obj[done_oid].trk[done_tid].seg[done_sid].regions.length - 1;
      if ( local_offset_now !== remote_offset_end ) {
        // fetch the remaining values
        fetch_next.push( [done_oid, done_tid, done_sid, local_offset_now, remote_offset_end] )
      }
    }
  }

  // 2. Do we have the latest data from status['now'] = {oid,tid,sid,tstart,tnow,tend}
  if ( status_new['now'].length ) {
    var now_oid    = status_new['now'][0];
    var now_tid    = status_new['now'][1];
    var now_sid    = status_new['now'][2];
    var remote_offset_now = status_new['now'][3];
    var remote_time_now   = status_new['now'][4];

    var local_offset_now = svt_project.obj[now_oid].trk[now_tid].seg[now_sid].regions.length - 1;
    if ( local_offset_now < remote_offset_now ) {
      // fetch the remaining values
      fetch_next.push( [now_oid, now_tid, now_sid, local_offset_now, remote_offset_now] )
    }
  }

  return fetch_next;
}

function _svt_fetch_track(fetch_next, invoke_this_when_done, delay) {
  if ( ! _svt_is_tracking_ongoing ) {
    return;
  }

  var xhr = new XMLHttpRequest();
  xhr.addEventListener('load', function() {
    try {
      var d = JSON.parse(xhr.responseText);
      svt_project.update_from_fetch(d);
      svt_project.update_buf_from_fetch(d, via_ng.v.now.tform.scale);
      if ( typeof(invoke_this_when_done) !== 'undefined' ) {
        setTimeout(invoke_this_when_done, delay);
      }
    }
    catch(err) {
      console.log(err)
    }
  });
  xhr.addEventListener('error', function(e) {
    via_ng.c.show_message('Failed to connect to the SVT server!');
    console.log(e)
  });

  if ( fetch_next.length ) {
    xhr.open('POST', _svt_server_address + '/svt/fetch?task_id=' + now.task_id);
    xhr.send( JSON.stringify(fetch_next) );
  } else {
    xhr.open('GET', _svt_server_address + '/svt/fetch?task_id=' + now.task_id);
    xhr.send();
  }
}

function _svt_stop_tracking() {
  var xhr = new XMLHttpRequest();
  xhr.addEventListener('load', function() {
    try {
      var d = JSON.parse(xhr.responseText);
      if ( d.status = 'ok' ) {
        _svt_on_stop_tracking();
        via_ng.c.show_message('Tracking stopped');
      } else {
        via_ng.c.show_message('Failed to stop tracking: [' + d.status + ']');
      }
    }
    catch(err) {
      console.log(err)
    }
  });
  xhr.addEventListener('error', function(e) {
    via_ng.c.show_message('Failed to connect to the SVT server!');
    console.log(e)
  });
  xhr.open('POST', _svt_server_address + '/svt/stop?task_id=' + now.task_id);
  xhr.send();
}

function _svt_on_stop_tracking() {
  now.task_id = '';
  _svt_is_tracking_ongoing = false;
}

//
// Annotation Visualizer
//

function _svt_av_show_tracks() {
  _svt_show_tracks = true;
  _svt_av_draw_current_buf();
}

function _svt_av_hide_tracks() {
  _svt_show_tracks = false;
}

function _svt_av_update_object_buf(oid) {

}

function _svt_av_update_trk_buf(oid, tid) {
}

function _svt_av_update_rid_buf(oid, tid, rid) {
}

function _svt_av_draw_current_buf(){
  if ( ! _svt_show_tracks ) {
    return;
  }

  var time = via_ng.v.now.content.currentTime;
  var frame_index = svt_project.buf.time2index(time);
  var keyframe_index = svt_project.buf.video_frames[ frame_index ];

  if ( typeof(keyframe_index) !== 'undefined' &&
       _svt_last_drawn_frame_index !== frame_index ) {
    var nr = svt_project.buf.keyframe[ keyframe_index ].length;
    var i;

    // clear canvas
    rctx.clearRect(0, 0, rcanvas.width, rcanvas.height);
    rctx.lineWidth = 2;

    var object_color_index;
    for ( i = 0; i < nr; i = i + 6 ) {
      object_color_index = svt_project.buf.keyframe[ keyframe_index ][i] % SVT_OBJECT_COLOR_LIST.length;
      rctx.strokeStyle = SVT_OBJECT_COLOR_LIST[object_color_index];

      /*
      if ( svt_project.buf.keyframe[ keyframe_index ][i+1] === 1 ) {
        rctx.setLineDash([10, 4]);
      } else {
        rctx.setLineDash([]); // solid line for automatically detected region
      }*/

      rctx.strokeRect( svt_project.buf.keyframe[ keyframe_index ][i+2], // x
                       svt_project.buf.keyframe[ keyframe_index ][i+3], // y
                       svt_project.buf.keyframe[ keyframe_index ][i+4], // width
                       svt_project.buf.keyframe[ keyframe_index ][i+5]  // height
                     );
    }
    if ( _svt_is_tracking_ongoing ) {
      if ( via_ng.v.now.content.paused ) {
        via_ng.v.now.content.play();
      }
    }
  } else {
    rctx.clearRect(0, 0, rcanvas.width, rcanvas.height);
    if ( _svt_is_tracking_ongoing ) {
      via_ng.v.now.content.pause();
    }
  }
  setTimeout( _svt_av_draw_current_buf, TRACK_DRAW_INTERVAL );
}
